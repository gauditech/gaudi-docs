---
sidebar_position: 2
sidebar_label: Customizing with Actions
title: Customizing with Actions
---

# Customizing with Actions

## How it works

Gaudi supports several actions which help you describe the behavior of an endpoint. Actions are declarative, but the ordering of the actions matters, which also makes them somewhat imperative.

### Context and aliases

Each action can define an alias using `as` keyword. This stores the result of the action in the context, and makes it possible to reference the results in the following actions. Aliases in the context represent immutable data.

Here's an example that describes the behavior:

```javascript
update user as updatedUser {
  input { username }
}

create UsernameLog {
  set userId user.id
  set old user.username // this hasn't changed
  set new updatedUser.username // this is the updated value
}
```

### Fieldsets

Fieldset is a collection of user inputs for a specific endpoint. This corresponds to data an endpoint expects in a HTTP body, in JSON format.

Fieldsets are generated based on endpoint actions and extra inputs.

Here's how the fieldset is calculated:

- include every field defined inside `extra inputs` in the root namespace
- for every `create` and `update` action:
  - namespace equals to `alias`
  - `id` is never included in the fieldset
  - if there's a `set` atom, field is not included in the fieldset
  - if action target is a relationship to an existing record, the parent `reference` is not included in the fieldset
  - if the reference relationship is created via `reference through`, the target field replaces the reference field
  - if there's a `default` in a field specification, the field is **optional**
  - in `update`, inputs must be explicitly declared using `input` atom
  - in `create`, every field not covered by previous rules is included as a required input



Here is an example snippet we can use to demonstrate how fieldsets are created:

```javascript

// let's define our models first
model Org {
  field name { type string }
  field paymentPlan { type string }
  relation memberships { from OrgMembership, through org }
}

model User {
  field email { type string }
  field acceptsTos { type boolean, default false }
  relation orgMemberships { from OrgMembership, through user }
}

model OrgMembership {
  reference org { to Org }
  reference user { to User }
}

api {
  entrypoint Org {
    create endpoint {
      action {
        create as org {
          set paymentPlan "freemium"
        }
        create User as user {}
        // creating org.memberships automatically
        // sets membership.org to `org` 
        create org.memberships as membership {
          set user user
        }
      }
    }
  }
}
```

Here is an example JSON body that constitutes a correct HTTP body:

```json
{
  "org": { "name": "Acme Inc" },
  "user": { "email": "john.doe@gaudi.tech" },
}
```

Here's a table that clarifies this even further:

| Alias         | Table name    | Field        |  In fieldset                            |
|-------------- |---------------|--------------|-----------------------------------------|
| org           | Org           |  id          | **no** - id field is autogenerated      |
|               |               |**name**      | **required**                            |
|               |               |  paymentPlan | **no** - set on the server side         |
| user          | User          |  id          | **no** - id field is autogenerated      |
|               |               |**email**     | **required**                            |
|               |               |**acceptsTos**| **optional** - has a default value      |
| membership    | OrgMembership |  id          | **no** - id field is autogenerated      |
|               |               |  org_id      | **no** - set on the server side         |
|               |               |  user_id     | **no** - set on the server side         |


## Types of actions

### `create`

Create action operates on a collection of data. It supports `input` and `set` atoms.

By default, `create` will turn every model `field` into `input`, unless a `default` value is provided in the field specification - in that case, `set` will be used instead.

#### Syntax

```javascript
create Org as myOrg { ... }
```

### `update`

Update action operates on a single record. It supports `input` and `set` atoms. For security reasons, `input` atoms must be explicit. You can use `input *` to mark all fields as updateable.

#### Syntax

```javascript
update myOrg as updatedOrg {
  input { name, description }
}
```

### `delete`

Delete action operates on any kind of relationship - supporting both single records and collections. It doesn't support any atoms, and can't have an `alias`.

#### Syntax

```javascript
delete org.repos {}
```

### `validate`

A `validate` action can be used to run custom validation expressions. It expects a `key` which specifies how the errors will be packed into a response object when validation errors occur.

#### Syntax

```javascript
create Org as org {}

// ensure description is different than name
validate with key "description" { isNotEqual(org.name, org.description) }
```

:::info
You can read more on data validation on a **dedicated data validation page**.
:::

### `query`

Query action is used to query data relationships and run operations on top of the results. `query` supports `select`, `update` and `delete` atoms.

#### Syntax

```javascript
// make all user posts private
query as updatedPosts {
  from User.posts,
  filter { isDeleted is false },
  update {
    set isPublic false
  }
}
```

#### Usage of select

:::info

Select can't be used with `delete`. It can **optionally** be used otherwise. If you omit `select`, Gaudi will use automatic dependency collection based on future references of an alias. However, providing explicit `select` turns this `alias` into a `struct` type. This is explained in more detail **here**.
:::

### `respond`

Respond action can be used in custom endpoints specify which data should be sent via HTTP response. This is similar to `response` in the crud endpoints. It accepts a `struct` type, so most of the time you'll have to `query` with `select` to fetch the data to respond with.

#### Syntax

```javascript

query as updated {
  from Org,
  update { set foo "foo" },
  select { id, name, foo }
}
respond {
  body updated
  headers {
    "My custom header" stringify(count(updated))
  }
}
```


### `execute`



## Supported atoms


### `create`, `update`

`create` and `update` operate on a single record, as per **cardinality rules**.

These are the only actions that can accept user inputs. See **fieldsets** for more info.

Here are some examples:

```javascript
create Org as newOrg {}

update newOrg as newNewOrg {
  input { name }
}

create org.memberships {
  set user @auth
  set role "admin"
}
```




#### Setter hooks

`set` keyword can compute a value using a **hook**:

```javascript

set nameAndDesc hook {
  arg name name
  arg desc description
  inline '`${name} and ${desc}`'
}